<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="Parallel Graph Coloring Project" />
        <meta name="author" content="svattiku, balasubs" />
        <title>Parallel Graph Coloring Project</title>
        <!-- Bootstrap core CSS -->
        <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet" />
        <style>
            .header {
                padding: 80px 0;
                background-color: #f8f9fa;
                margin-bottom: 30px;
            }
            .section {
                margin-bottom: 40px;
            }
            .timeline-item {
                position: relative;
                padding-bottom: 20px;
                border-left: 2px solid #0d6efd;
                padding-left: 20px;
                margin-left: 10px;
            }
            .timeline-item:before {
                content: '';
                position: absolute;
                left: -9px;
                top: 0;
                width: 16px;
                height: 16px;
                border-radius: 50%;
                background-color: #0d6efd;
            }
            .heading-underline {
                border-bottom: 3px solid #0d6efd;
                padding-bottom: 10px;
                display: inline-block;
                margin-bottom: 20px;
            }
        </style>
    </head>
    <body>
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container">
                <a class="navbar-brand" href="#">Parallel Graph Coloring</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
                        <li class="nav-item"><a class="nav-link" href="#summary">Summary</a></li>
                        <li class="nav-item"><a class="nav-link" href="#background">Background</a></li>
                        <li class="nav-item"><a class="nav-link" href="#parallelization">Parallelization Approaches</a></li>
                        <li class="nav-item"><a class="nav-link" href="#challenges">Challenges</a></li>
                        <li class="nav-item"><a class="nav-link" href="#resources">Resources</a></li>
                        <li class="nav-item"><a class="nav-link" href="#platform">Platform Choice</a></li>
                        <li class="nav-item"><a class="nav-link" href="#goals">Goals</a></li>
                        <li class="nav-item"><a class="nav-link" href="#schedule">Schedule</a></li>
                    </ul>
                </div>
            </div>
        </nav>
        
        <!-- Header-->
        <header class="header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-12 text-center">
                        <h1 class="display-4">Parallel Graph Coloring</h1>
                        <p class="lead">Andrew Id: svattiku, balasubs</p>
                        <div class="mt-3">
                            <span class="badge bg-secondary me-2">OpenMP</span>
                            <span class="badge bg-secondary me-2">MPI</span>
                            <span class="badge bg-secondary">C/C++</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Page content-->
        <div class="container">
            <!-- Summary Section -->
            <section id="summary" class="section">
                <h2 class="heading-underline">Summary</h2>
                <p>For our final project, we will implement and analyze multiple parallel approaches to the graph coloring problem. We'll develop traditional parallelization strategies alongside a focus on a novel transactional memory-inspired approach that uses optimistic execution with conflict resolution.</p>
            </section>
            
            <!-- Background Section -->
            <section id="background" class="section">
                <h2 class="heading-underline">Background</h2>
                <p>Graph coloring assigns colors to nodes such that no adjacent nodes share the same color. This problem has many applications, including register allocation in compilers, scheduling problems, and frequency assignment in wireless networks. The minimum graph coloring problem (finding the coloring with the fewest colors) is NP-Complete, so approximation algorithms are typically used.</p>
                <p>The greedy approach is one of the most common approximation algorithms for graph coloring. It assigns the lowest possible color to each vertex while ensuring no conflicts with already-colored neighbors. While simple, this sequential approach can be slow for large graphs, and computation increases as the graph size increases.</p>
            </section>

            <section id="schedule" class="section">
                <h2 class="heading-underline">Reports</h2>
                <ul>
                    <li><a href="https://docs.google.com/document/d/14gqad6gpqpYnV0P8PvT2AAHaMQVIFNSazMd6C6fgtBo/edit?usp=sharing">Project Proposal </a></li>
                    <li><a href="https://docs.google.com/document/d/1wrbilUa-NF_DV-cKDy1_89zxCsobhO_-4e7auvMijbw/edit?usp=sharing">Milestone Report </a></li>
                    <li><a href="https://docs.google.com/document/d/190nT773tgC9RDjq-VyMwDP70Zm1MNf-UdYhVxKa0Mk8/edit?usp=sharing">Final Report </a></li>
                </ul>
            </section>

            <!-- Parallelization Approaches Section -->
            <section id="parallelization" class="section">
                <h2 class="heading-underline">Parallelization Approaches</h2>
                <h3>Traditional Parallel Approaches</h3>
                <p>We will implement the following traditional approaches using both OpenMP (for shared memory parallelism) and MPI (for distributed memory parallelism) to evaluate their performance characteristics, scalability, and effectiveness across different graph structures:</p>
                
                <div class="row">
                    <div class="col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5 class="card-title">1. Independent Set Coloring</h5>
                                <p><strong>Concept:</strong> Identifying sets of vertices that can be colored simultaneously without conflicts</p>
                                <p><strong>Implementation:</strong> Using OpenMP for thread-level parallelism and MPI for distributed identification and coloring of independent sets</p>
                                <p><strong>Challenge:</strong> Efficiently identifying maximal independent sets in parallel</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 mb-4">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5 class="card-title">2. Domain Decomposition</h5>
                                <p><strong>Concept:</strong> Partitioning the graph into subgraphs and coloring them in parallel</p>
                                <p><strong>Implementation:</strong> Using OpenMP for shared memory decomposition and MPI for distributed partitioning with special handling for boundary vertices</p>
                                <p><strong>Challenge:</strong> Managing cross-partition conflicts while maintaining load balance</p>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>Novel Transactional Memory-Inspired Approach</h3>
                <h4>3. Optimistic Parallel Coloring with Conflict Resolution</h4>
                <p><strong>Concept:</strong> Mimicking transactional memory systems by allowing threads to color vertices optimistically in parallel without synchronization, then detecting and resolving conflicts afterward</p>
                
                <h5>Implementation</h5>
                <ul>
                    <li>For shared memory: Using OpenMP with custom atomic operations for conflict detection and resolution</li>
                    <li>For distributed memory: Using MPI with specialized message-passing protocols for cross-process conflict management</li>
                </ul>

                <h5>Key Components</h5>
                <h6>Conflict Detection</h6>
                <p>After initial coloring, a parallel scan over edges identifies pairs of adjacent vertices with the same color, recording conflicts in dedicated data structures. This post-processing approach uses atomic operations to mark conflicts without serializing the detection process, enabling efficient bulk conflict identification.</p>

                <h6>Resolution Strategies</h6>
                <p>Several sophisticated approaches will be explored including:</p>
                <ul>
                    <li>Priority-based resolution (higher priority vertices keep colors)</li>
                    <li>Timestamp ordering (earlier colored vertices maintain colors)</li>
                    <li>Probabilistic resolution with exponential backoff for recoloring attempts</li>
                </ul>
                <p>These strategies balance conflict resolution quality against computational overhead.</p>

                <h6>Performance Optimizations</h6>
                <p>We will explore optimizations with:</p>
                <ul>
                    <li>Versioned color assignments to track changes</li>
                    <li>Contention management to reduce hotspots</li>
                    <li>Careful memory consistency model design</li>
                </ul>
                <p>Fine-grained state tracking monitors whether vertices are in tentative, committed, or conflicted states throughout the coloring process.</p>

                <h4>Relation to Hardware Lock Elision (HLE)</h4>
                <p>Our approach shares important conceptual foundations with HLE, a feature in modern processors that enables threads to execute critical sections concurrently without locks:</p>
                <ul>
                    <li>Both use optimistic execution assuming conflicts are rare</li>
                    <li>While HLE leverages hardware transactional memory to detect conflicts at the processor level, our approach implements similar capabilities in software</li>
                    <li>For systems with processors supporting Intel TSX instructions, we will explore potential hybrid implementations that leverage actual hardware transactional memory support for conflict detection</li>
                </ul>
                <p>This connection highlights how our software approach mirrors hardware-level optimization techniques in modern processor architectures.</p>

                <h4>Key Differences Between Approaches</h4>
                <ul>
                    <li><strong>Philosophy:</strong> Traditional approaches prevent conflicts through synchronization; transactional approach allows conflicts and resolves them afterward.</li>
                    <li><strong>Synchronization:</strong> Traditional approaches require coordinated coloring; transactional approach enables independent thread operation.</li>
                    <li><strong>Conflict Handling:</strong> Traditional approaches avoid conflicts by design; transactional approach detects and resolves conflicts post-coloring.</li>
                    <li><strong>Execution Model:</strong>
                        <ul>
                            <li>Independent Set colors non-adjacent vertices simultaneously</li>
                            <li>Domain Decomposition partitions and colors with boundary handling</li>
                            <li>Transactional approach uses optimistic coloring with conflict resolution</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <!-- Challenges Section -->
            <section id="challenges" class="section">
                <h2 class="heading-underline">Challenges</h2>
                <h3>Load Balancing</h3>
                <p>Graphs often have non-uniform structures, leading to load imbalance when parallelized. We will investigate dynamic load balancing techniques to distribute work evenly among processors, particularly for irregular graphs.</p>

                <h3>Dependency Management</h3>
                <p>The primary challenge in parallelizing graph coloring is managing dependencies between vertices. Since a vertex's color depends on its neighbors, naive parallelization can lead to race conditions where neighboring vertices receive the same color.</p>

                <h3>Performance-Quality Tradeoffs</h3>
                <p>Parallel implementations may use more colors than the sequential greedy algorithm. We will analyze this tradeoff between coloring quality and performance improvement, and explore techniques to minimize the color count while maintaining speedup.</p>

                <h3>Additional Specific Challenges</h3>
                <ul>
                    <li>Balancing Optimism: Finding the right balance between optimistic coloring and conflict resolution overhead</li>
                    <li>Scalable Conflict Detection: Making conflict detection efficient as thread count increases</li>
                    <li>Color Count Control: Preventing resolution strategies from significantly increasing color count</li>
                </ul>
            </section>

            <!-- Resources Section -->
            <section id="resources" class="section">
                <h2 class="heading-underline">Resources</h2>
                <p>Our approach will start with developing a C/C++ implementation of the sequential greedy graph coloring algorithm as our foundation. Once we have a working sequential version, we'll extend it to create a parallel implementation. We'll conduct our initial development on the GHC machines, but for comprehensive performance evaluation of our final implementations, we plan to utilize the PSC machines with their superior core counts.</p>
            </section>

            <!-- Platform Choice Section -->
            <section id="platform" class="section">
                <h2 class="heading-underline">Platform Choice</h2>
                <p>We'll leverage multi-core GHC and PSC machines for our implementation. C/C++ was selected based on our prior assignment experience with OpenMP and OpenMPI-frameworks well-suited to the parallel approaches described in our background section.</p>
            </section>

            <!-- Goals and Deliverables Section -->
            <section id="goals" class="section">
                <h2 class="heading-underline">Goals and Deliverables</h2>
                <h3>Plan to Achieve (Baseline)</h3>
                <ul>
                    <li>Sequential implementation of greedy graph coloring</li>
                    <li>OpenMP implementation with reasonable speedup on shared memory systems</li>
                    <li>Basic MPI implementation for distributed memory systems</li>
                    <li>Implementation of transactional memory-inspired approach with:
                        <ul>
                            <li>Optimistic parallel coloring mechanism</li>
                            <li>Conflict detection and recording system</li>
                            <li>Two conflict resolution strategies:
                                <ul>
                                    <li>Priority-based resolution (higher priority vertices keep colors)</li>
                                    <li>Timestamp ordering (earlier colored vertices maintain colors)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Performance analysis across different graph types and system configurations</li>
                </ul>

                <h3>Hope to Achieve (Stretch Goals)</h3>
                <ul>
                    <li>Achieve near-linear speedup for sparse graph classes by optimizing cache utilization and reducing synchronization overhead</li>
                    <li>Develop advanced heuristics to minimize color count in parallel implementations while maintaining performance</li>
                    <li>Implement an adaptive framework that automatically selects the optimal parallelization strategy based on graph density, size, and available hardware</li>
                </ul>
            </section>

            <!-- Schedule Section -->
            <section id="schedule" class="section">
                <h2 class="heading-underline">Schedule</h2>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Week</th>
                            <th>To-Do</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Week 1</td>
                            <td>
                                <ul>
                                    <li>Implement and optimize sequential greedy graph coloring</li>
                                    <li>Set up testing framework and graph datasets</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td>Week 2</td>
                            <td>
                                <ul>
                                    <li>Develop traditional parallel algorithm implementation</li>
                                    <li>Benchmark and analyze performance on shared memory systems</li>
                                    <li>Explore transactional memory conflict detection strategies</li>
                                </ul>
                            </td>
                            <tr>
                            <td>Week 3</td>
                            <td>
                                <ul>
                                    <li>Prepare and submit project milestone report (April 15th)</li>
                                    <li>Continue transactional memory approach - implement strategies</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td>Week 4</td>
                            <td>
                                <ul>
                                    <li>Complete transactional memory approach</li>
                                    <li>Conduct comparative analysis</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td>Week 5</td>
                            <td>
                                <ul>
                                    <li>Finalize optimizations</li>
                                    <li>Prepare final report and presentation materials</li>
                                    <li>Prepare for project poster session</li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <td>Final Deliverables</td>
                            <td>
                                <ul>
                                    <li>Final Project Report (April 28th)</li>
                                    <li>Project Poster Session (April 29th)</li>
                                </ul>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Footer-->
            <footer class="py-5 bg-dark text-white mt-5">
                <div class="container text-center">
                    <p class="m-0">Parallel Graph Coloring Project</p>
                    <p class="m-0">Andrew Id: svattiku, balasubs</p>
                    <p class="m-0">URL: pca-project</p>
                </div>
            </footer>
        </div>
