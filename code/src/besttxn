#include "graph.h"
#include <vector>
#include <algorithm>
#include <numeric>
#include <cstring>

class OptimizedColorGraph : public ColorGraph {
private:
    // Flat graph representation to eliminate map lookups
    struct FlatGraph {
        std::vector<int> offsets;    // Node start positions in edges array
        std::vector<int> edges;      // Flattened adjacency lists
        
        void build(const std::vector<std::pair<int, int>>& edgePairs, int numNodes) {
            // Pre-allocate memory for offsets
            offsets.resize(numNodes + 1, 0);
            
            // Count degrees first to avoid reallocations
            for (const auto& edge : edgePairs) {
                offsets[edge.first + 1]++;
                offsets[edge.second + 1]++;
            }
            
            // Calculate prefix sum for offsets
            for (int i = 1; i <= numNodes; i++) {
                offsets[i] += offsets[i-1];
            }
            
            // Pre-allocate edges array
            edges.resize(offsets[numNodes]);
            
            // Make a copy of offsets to use as insertion points
            std::vector<int> nextPos = offsets;
            
            // Fill edges array
            for (const auto& edge : edgePairs) {
                edges[nextPos[edge.first]++] = edge.second;
                edges[nextPos[edge.second]++] = edge.first;
            }
        }
        
        // Get neighbors range for vertex v
        std::pair<const int*, const int*> neighbors(int v) const {
            return {&edges[offsets[v]], &edges[offsets[v+1]]};
        }
        
        // Get degree of vertex v
        int degree(int v) const {
            return offsets[v+1] - offsets[v];
        }
    };

public:
    void buildGraph(std::vector<graphNode> &nodes, std::vector<std::pair<int, int>> &pairs,
                   std::unordered_map<graphNode, std::vector<graphNode>> &graph) override {
        // Just store node count and edge pairs directly - defer CSR construction until coloring
        for (auto &node : nodes) {
            graph[node] = {}; // Initialize but don't populate yet
        }
        
        // We're just building a minimal placeholder here to satisfy the interface
        // Real work is done during coloring with our flat representation
    }

    void colorGraph(std::unordered_map<graphNode, std::vector<graphNode>> &graph,
                   std::unordered_map<graphNode, color> &colors) override {
        const int numNodes = static_cast<int>(graph.size());
        if (numNodes == 0) return;
        
        // Extract edge pairs from graph map (just once to avoid repeated map lookups)
        std::vector<std::pair<int, int>> edgePairs;
        edgePairs.reserve(graph.size() * 8); // Estimate average degree of 8
        
        for (const auto& [node, neighbors] : graph) {
            for (auto neighbor : neighbors) {
                if (node < neighbor) { // Add each edge only once
                    edgePairs.emplace_back(node, neighbor);
                }
            }
        }
        
        // Build flat graph representation
        FlatGraph flatGraph;
        flatGraph.build(edgePairs, numNodes);
        
        // Use a flat array for colors
        std::vector<color> nodeColors(numNodes, -1);
        
        // Compute vertex ordering by degree (largest first)
        std::vector<int> vertices(numNodes);
        std::iota(vertices.begin(), vertices.end(), 0);
        
        std::sort(vertices.begin(), vertices.end(), 
            [&flatGraph](int a, int b) {
                return flatGraph.degree(a) > flatGraph.degree(b);
            });
        
        // Thread-local bitmap size (start with reasonable size, will grow if needed)
        const int initialBitmapSize = 256;
        int maxColor = 0;
        
        // Color nodes in parallel
        #pragma omp parallel
        {
            // Thread-local bitmap for forbidden colors
            std::vector<bool> forbidden(initialBitmapSize, false);
            
            #pragma omp for schedule(dynamic, 64) reduction(max:maxColor)
            for (int i = 0; i < numNodes; i++) {
                const int v = vertices[i];
                
                // Clear previous forbidden marks (faster than re-allocating)
                std::fill(forbidden.begin(), forbidden.end(), false);
                
                // Mark colors of neighbors as forbidden
                auto [begin, end] = flatGraph.neighbors(v);
                for (auto it = begin; it != end; ++it) {
                    const int nbor = *it;
                    const color nborColor = nodeColors[nbor];
                    
                    if (nborColor >= 0) {
                        // Resize forbidden if needed
                        if (nborColor >= static_cast<int>(forbidden.size())) {
                            forbidden.resize(nborColor + 1, false);
                        }
                        forbidden[nborColor] = true;
                    }
                }
                
                // Find smallest available color
                color selected = 0;
                while (selected < static_cast<int>(forbidden.size()) && forbidden[selected]) selected++;
                
                nodeColors[v] = selected;
                maxColor = std::max(maxColor, selected);
            }
        }
        
        // Use atomic operations for conflict resolution (no need for a separate phase)
        #pragma omp parallel for schedule(dynamic, 64)
        for (int v = 0; v < numNodes; v++) {
            auto [begin, end] = flatGraph.neighbors(v);
            
            for (auto it = begin; it != end; ++it) {
                const int nbor = *it;
                
                // Resolve conflicts - higher degree node keeps its color
                if (nodeColors[v] == nodeColors[nbor] && v > nbor) {
                    // Atomically update colors map to avoid race conditions
                    #pragma omp critical
                    {
                        // Re-color by finding next available color
                        std::vector<bool> forbidden(maxColor + 1, false);
                        
                        auto [n_begin, n_end] = flatGraph.neighbors(v);
                        for (auto n_it = n_begin; n_it != n_end; ++n_it) {
                            const int n = *n_it;
                            if (nodeColors[n] >= 0 && nodeColors[n] < static_cast<int>(forbidden.size())) {
                                forbidden[nodeColors[n]] = true;
                            }
                        }
                        
                        color newColor = 0;
                        while (newColor < static_cast<int>(forbidden.size()) && forbidden[newColor]) newColor++;
                        
                        nodeColors[v] = newColor;
                    }
                }
            }
        }
        
        // Transfer colors to output map - unavoidable due to interface
        for (int i = 0; i < numNodes; i++) {
            colors[i] = nodeColors[i];
        }
    }
};

std::unique_ptr<ColorGraph> createTransactionalColorGraph() {
    return std::make_unique<OptimizedColorGraph>();
}